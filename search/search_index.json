{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 Commander is an open sourced administration panel meant to be used in Roblox experiences, to provide a much intuitive and easygoing way to do game moderation. Created by programmers and artists around the world with love. Version Two \u00b6 This documentation only applies to version two, which is currently under development, for those who are looking for version one, head to this site . License \u00b6 Commander is licensed under the MIT license.","title":"Home"},{"location":"#home","text":"Commander is an open sourced administration panel meant to be used in Roblox experiences, to provide a much intuitive and easygoing way to do game moderation. Created by programmers and artists around the world with love.","title":"Home"},{"location":"#version-two","text":"This documentation only applies to version two, which is currently under development, for those who are looking for version one, head to this site .","title":"Version Two"},{"location":"#license","text":"Commander is licensed under the MIT license.","title":"License"},{"location":"roadmap/","text":"V2 Roadmap \u00b6 We are shifting our focus to the upcoming version of Commander, which is V2. This page contains a list of features/tasks being worked on, so you can catch up with the progress. Name Description Status Assignee Remote listener Add a listener to remote function and remote events \u2705 @7kayoh Base remote listeners Add basic listeners such as commands \u23f3 No one Remote listener extensions Add support for plugins to extend the remote listener for other methods \u2705 @7kayoh API Add more API methods \u23f3 No one DataStores Set up Profiles for Commander user configurations \u23f3 No one BanUtil Finish the banning/unbanning mechanism for both local and global ban, and set up the Profiles for global banning \u23f3 No one Built-in commands Create a few built-in commands for Commander \u23f3 No one Frontend recode Completely rewrite the frontend with the osm framework \u23f3 No one Frontend extensions Add support for plugins to extend the UI for extra functionalities \u23f3 No one","title":"V2 Roadmap"},{"location":"roadmap/#v2-roadmap","text":"We are shifting our focus to the upcoming version of Commander, which is V2. This page contains a list of features/tasks being worked on, so you can catch up with the progress. Name Description Status Assignee Remote listener Add a listener to remote function and remote events \u2705 @7kayoh Base remote listeners Add basic listeners such as commands \u23f3 No one Remote listener extensions Add support for plugins to extend the remote listener for other methods \u2705 @7kayoh API Add more API methods \u23f3 No one DataStores Set up Profiles for Commander user configurations \u23f3 No one BanUtil Finish the banning/unbanning mechanism for both local and global ban, and set up the Profiles for global banning \u23f3 No one Built-in commands Create a few built-in commands for Commander \u23f3 No one Frontend recode Completely rewrite the frontend with the osm framework \u23f3 No one Frontend extensions Add support for plugins to extend the UI for extra functionalities \u23f3 No one","title":"V2 Roadmap"},{"location":"manual/api/","text":"API \u00b6 The API is a collection of reusable functions that helps to reduce the size of a package, or for developers to communicate with Commander externally. As the API is exposed to the server context, please be aware of backdoors, as they may have codes to intervene Commander. Use-cases \u00b6 The API offers opportunities for developers to create lightweight, safe and stable packages for Commander without putting too much focus on compatability. Here are the reasons why you should consider using the API instead of reinventing the wheels: Maintained by the official developers The API is always up-to-date with the entire codebase and has been seriously tested before release, it is by far the most optimal way to create scalable packages. Code safety All code found in the API is coded with caution, the chances of it breaking out of random is rare and physically impossible to happen. Saves line With the use of the API, you can easily make your package extremely lightweight, as majority of the code has been replaced by API methods instead. Methods \u00b6 Players \u00b6 API.checkUserAdmin \u00b6 boolean API.checkuserAdmin( player Player) Returns the administrator status of the user, API.getAdminStatusWithUserId \u00b6 number, string API.getAdminStatusWithUserId( integer UserId) Returns the administration group index and name of the player is in. This method is for when the player is not ingame. API.getAdminLevel \u00b6 number, string API.getAdminLevel( player Player) Returns the administration group index and name of the player is in. API.initializePlayer \u00b6 nil API.initializePlayer( player Player) Initializes the player, this is not needed as Commander already calls this to every player by default. API.wrapPlayer \u00b6 table API.wrapPlayer( player Player) Returns a wrapper of the player. By default, the wrapper contains the following elements: { [ \"Name\" ] = Player . Name , [ \"DisplayName\" ] = Player . DisplayName , [ \"UserId\" ] = Player . UserId , [ \"Character\" ] = Player . Character , [ \"IsAdmin\" ] = API . checkUserAdmin ( Player ), [ \"_instance\" ] = Player } API.getProfile \u00b6 profile API.getProfile( string|integer user) :hourglass-flowing-sand: Asynchronous operation Returns the profile of the user Release the profile once you are done working with it, for more details, refer to the documentation for ProfileService Misc \u00b6 API.addChecker \u00b6 nil API.addChecker( string Name, function Checker) Loads in a checker given in the function call, will be called when a player joins. API.extendPlayerWrapper \u00b6 nil API.extendPlayerWrapper( function Extender) Loads in an extender given in the function call, will be called when .wrapPlayer is requested. API.Initialize \u00b6 nil API.Initialize( Folder remotesFolder) Avoid touching this part, this is meant to be used internally. API.addRemoteTask \u00b6 table API.addRemoteTask( string remoteType, function|string qualifier, function handler) Adds a new task to the corresponding, useful when you want to listen RemoteFunction/Event requests. Accepted remoteTypes: \"Function\" , \"Event\" Returns a table, for you to remove the task once you no longer want to listen: local task = API . addRemoteTask ( \"Function\" , \"onRequest\" , function ( player , requestType , ...) return true end ) task . leave () -- leaves When a handler is being fired, you are expected to receive the player wrapper, the request type, and the arguments.","title":"API"},{"location":"manual/api/#api","text":"The API is a collection of reusable functions that helps to reduce the size of a package, or for developers to communicate with Commander externally. As the API is exposed to the server context, please be aware of backdoors, as they may have codes to intervene Commander.","title":"API"},{"location":"manual/api/#use-cases","text":"The API offers opportunities for developers to create lightweight, safe and stable packages for Commander without putting too much focus on compatability. Here are the reasons why you should consider using the API instead of reinventing the wheels: Maintained by the official developers The API is always up-to-date with the entire codebase and has been seriously tested before release, it is by far the most optimal way to create scalable packages. Code safety All code found in the API is coded with caution, the chances of it breaking out of random is rare and physically impossible to happen. Saves line With the use of the API, you can easily make your package extremely lightweight, as majority of the code has been replaced by API methods instead.","title":"Use-cases"},{"location":"manual/api/#methods","text":"","title":"Methods"},{"location":"manual/api/#players","text":"","title":"Players"},{"location":"manual/api/#apicheckuseradmin","text":"boolean API.checkuserAdmin( player Player) Returns the administrator status of the user,","title":"API.checkUserAdmin"},{"location":"manual/api/#apigetadminstatuswithuserid","text":"number, string API.getAdminStatusWithUserId( integer UserId) Returns the administration group index and name of the player is in. This method is for when the player is not ingame.","title":"API.getAdminStatusWithUserId"},{"location":"manual/api/#apigetadminlevel","text":"number, string API.getAdminLevel( player Player) Returns the administration group index and name of the player is in.","title":"API.getAdminLevel"},{"location":"manual/api/#apiinitializeplayer","text":"nil API.initializePlayer( player Player) Initializes the player, this is not needed as Commander already calls this to every player by default.","title":"API.initializePlayer"},{"location":"manual/api/#apiwrapplayer","text":"table API.wrapPlayer( player Player) Returns a wrapper of the player. By default, the wrapper contains the following elements: { [ \"Name\" ] = Player . Name , [ \"DisplayName\" ] = Player . DisplayName , [ \"UserId\" ] = Player . UserId , [ \"Character\" ] = Player . Character , [ \"IsAdmin\" ] = API . checkUserAdmin ( Player ), [ \"_instance\" ] = Player }","title":"API.wrapPlayer"},{"location":"manual/api/#apigetprofile","text":"profile API.getProfile( string|integer user) :hourglass-flowing-sand: Asynchronous operation Returns the profile of the user Release the profile once you are done working with it, for more details, refer to the documentation for ProfileService","title":"API.getProfile"},{"location":"manual/api/#misc","text":"","title":"Misc"},{"location":"manual/api/#apiaddchecker","text":"nil API.addChecker( string Name, function Checker) Loads in a checker given in the function call, will be called when a player joins.","title":"API.addChecker"},{"location":"manual/api/#apiextendplayerwrapper","text":"nil API.extendPlayerWrapper( function Extender) Loads in an extender given in the function call, will be called when .wrapPlayer is requested.","title":"API.extendPlayerWrapper"},{"location":"manual/api/#apiinitialize","text":"nil API.Initialize( Folder remotesFolder) Avoid touching this part, this is meant to be used internally.","title":"API.Initialize"},{"location":"manual/api/#apiaddremotetask","text":"table API.addRemoteTask( string remoteType, function|string qualifier, function handler) Adds a new task to the corresponding, useful when you want to listen RemoteFunction/Event requests. Accepted remoteTypes: \"Function\" , \"Event\" Returns a table, for you to remove the task once you no longer want to listen: local task = API . addRemoteTask ( \"Function\" , \"onRequest\" , function ( player , requestType , ...) return true end ) task . leave () -- leaves When a handler is being fired, you are expected to receive the player wrapper, the request type, and the arguments.","title":"API.addRemoteTask"},{"location":"manual/packages/","text":"Packages \u00b6 Packages are a new feature that allows you to extend or create features for Commander without modifying the internal source code. They can be used as a command , a plugin , or a stylesheet . In this page, we will walk you through the basics of the Commander package system, and the package manager. Introduction \u00b6 Previously in V1, packages are basically commands in a nutshell, simple as that. The use of the term package was soemwhat redudant due to its sole usage is as a command only. As a result, we have redefined the definition of packages in V2. In V2, a package can be a command, a plugin, or a stylsheet. For plugin, it is not neccessary to return anything, it could be just a run-once code to extend or add features. Or modifies a specific module for greater performance or anything else. Standard template \u00b6 local package = { Name = \"Name\" , Description = \"Description\" , Author = \"User\" , Class = \"Command/Plugin/Stylesheet\" , Target = {} } function package . Target : Init () end return package package.Target:Init() is available for plugins, they will be called after initalization if it existed. Examples \u00b6 API Checker plugin A checker is a function that validates the user to determine whether the user is an administrator, and which group do they belong to. Luckily, the API has exposed a method to assign a new checker, which is API.addChecker ( read more ). First, create a package and use the standard format above local package = { Name = \"Checker\" , Description = \"Plugin Description\" , Author = \"User\" , Class = \"Plugin\" , Category = \"Server\" , Target = {} } function package . Target : Init () end return package Administration groups and assignee data can be found in the configuration module, which can be required via package.Core.Settings , you should initialize settings within the :Init() function. function package . Target : Init () package . Target . Settings = require ( package . Core . Settings ) end Now, we have to write the checker function, in this sitution, let's assume that you want to give everyone the highest administration group in the checker. It is not needed to follow this format for the checker, but it is recommended to do so, to maintain consistency within the ecosystem. Administration groups configuration can be accessed via Settings.Groups , where assignee data can be found in Settings.Permissions . The format of a group and assignee configuration can be found in this page A checker is expected to return an integer, which should be the index of the group configuration, inside the groups configuration table. function package . Target . onInvoke () return # package . Target . Settings . Groups -- This will give everyone the highest group end Now, once you are done writing the checker, make it so the API will load the checker, with the method API.addChecker function package . Target : Init () package . Target . Settings = require ( package . Core . Settings ) package . API . addChecker ( package . Target . onInvoke ) end That's all. Example command A command is used for the administrators to interact with Commander, it could be a command that helps administrators to moderate their game, or as a tool to help with administrators. In this example, we will be writing a simple command which prints out \"Hello World\" upon interaction. First, create a package by using the standard format, and fill in the essential information. We will be making this command as a server command. local package = { Name = \"Example\" , Description = \"An example command!\" , Author = \"User\" , Class = \"Command\" , Category = \"Server\" , Target = {} } function package . Target : Init () end return package function package . Target : Init () end The package.Target:Init() is an invoker function, it gets invoked when the player requested for this command, you can write in your main function for this command there. The invoker function will receive three arguments when invoked, which is the requester PlayerWrapper object, the request type, and finally the actual arguments provided by the requester -- the attachments. While this command will not make use of any of the arguments above, we will be writing it down below for your future reference. Now, let's write down our main function for this command, which is printing \"Hello World\" to the console. function package . Target : Init ( player , requestType , arguments ) print ( \"Hello World\" ) return true end Always return a boolean back to the requester Because this is an invoker function, the function requires to return something back to the client to avoid potential halting in the client side, while this will not affect the server, this can lead to a lot of problems to the client instead. If the command runs successfully (everything listed in the main function is completed), return a true boolean. Otherwise, return a false boolean along with the error message. That's all.","title":"Packages"},{"location":"manual/packages/#packages","text":"Packages are a new feature that allows you to extend or create features for Commander without modifying the internal source code. They can be used as a command , a plugin , or a stylesheet . In this page, we will walk you through the basics of the Commander package system, and the package manager.","title":"Packages"},{"location":"manual/packages/#introduction","text":"Previously in V1, packages are basically commands in a nutshell, simple as that. The use of the term package was soemwhat redudant due to its sole usage is as a command only. As a result, we have redefined the definition of packages in V2. In V2, a package can be a command, a plugin, or a stylsheet. For plugin, it is not neccessary to return anything, it could be just a run-once code to extend or add features. Or modifies a specific module for greater performance or anything else.","title":"Introduction"},{"location":"manual/packages/#standard-template","text":"local package = { Name = \"Name\" , Description = \"Description\" , Author = \"User\" , Class = \"Command/Plugin/Stylesheet\" , Target = {} } function package . Target : Init () end return package package.Target:Init() is available for plugins, they will be called after initalization if it existed.","title":"Standard template"},{"location":"manual/packages/#examples","text":"API Checker plugin A checker is a function that validates the user to determine whether the user is an administrator, and which group do they belong to. Luckily, the API has exposed a method to assign a new checker, which is API.addChecker ( read more ). First, create a package and use the standard format above local package = { Name = \"Checker\" , Description = \"Plugin Description\" , Author = \"User\" , Class = \"Plugin\" , Category = \"Server\" , Target = {} } function package . Target : Init () end return package Administration groups and assignee data can be found in the configuration module, which can be required via package.Core.Settings , you should initialize settings within the :Init() function. function package . Target : Init () package . Target . Settings = require ( package . Core . Settings ) end Now, we have to write the checker function, in this sitution, let's assume that you want to give everyone the highest administration group in the checker. It is not needed to follow this format for the checker, but it is recommended to do so, to maintain consistency within the ecosystem. Administration groups configuration can be accessed via Settings.Groups , where assignee data can be found in Settings.Permissions . The format of a group and assignee configuration can be found in this page A checker is expected to return an integer, which should be the index of the group configuration, inside the groups configuration table. function package . Target . onInvoke () return # package . Target . Settings . Groups -- This will give everyone the highest group end Now, once you are done writing the checker, make it so the API will load the checker, with the method API.addChecker function package . Target : Init () package . Target . Settings = require ( package . Core . Settings ) package . API . addChecker ( package . Target . onInvoke ) end That's all. Example command A command is used for the administrators to interact with Commander, it could be a command that helps administrators to moderate their game, or as a tool to help with administrators. In this example, we will be writing a simple command which prints out \"Hello World\" upon interaction. First, create a package by using the standard format, and fill in the essential information. We will be making this command as a server command. local package = { Name = \"Example\" , Description = \"An example command!\" , Author = \"User\" , Class = \"Command\" , Category = \"Server\" , Target = {} } function package . Target : Init () end return package function package . Target : Init () end The package.Target:Init() is an invoker function, it gets invoked when the player requested for this command, you can write in your main function for this command there. The invoker function will receive three arguments when invoked, which is the requester PlayerWrapper object, the request type, and finally the actual arguments provided by the requester -- the attachments. While this command will not make use of any of the arguments above, we will be writing it down below for your future reference. Now, let's write down our main function for this command, which is printing \"Hello World\" to the console. function package . Target : Init ( player , requestType , arguments ) print ( \"Hello World\" ) return true end Always return a boolean back to the requester Because this is an invoker function, the function requires to return something back to the client to avoid potential halting in the client side, while this will not affect the server, this can lead to a lot of problems to the client instead. If the command runs successfully (everything listed in the main function is completed), return a true boolean. Otherwise, return a false boolean along with the error message. That's all.","title":"Examples"},{"location":"manual/plugins/","text":"Plugins \u00b6 In V2, we have introduced a brand new package system with a new package type called Plugin , which is used to extend existing features or add new features to Commander. Those can be UI plugins, API plugins, or plugins used by commands. In this page, we will walk you through the process of creating a plugin for Commander. Preparations \u00b6 Before building, we need: A proper installation of Commander 2.x.x Roblox Studio Rojo & External Code Editor (Optional) Start \u00b6 To make a plugin recognizable by Commander, you need to ensure the source file has the proper format and declares itself as a Plugin package. So, copy and paste the standard package format, which can be found here or in the page about packages in general. local package = { Name = \"Plugin\" , Description = \"Plugin Description\" , Author = \"User\" , Class = \"Plugin\" , Target = {} } function package . Target : Init () end return package It is also recommended to add the above code as a code snippet for future use. For plugins, Commander will call :Init() once all loading for packages has been complete, this includes injecting the necessary dependencies. If your plugin have to require dependencies found in the Core folder, but not in the Preloaded folder, it is a better idea to initialize those dependencies within the :Init() function, and assign them into the package.Target table. A plugin is not necessary to expose methods, a plugin can be a piece of run-once code. Plugins are injected automatically into the commands only, if you are attempting to adjust the API inside a plugin, it is best to look at the API documentation to see is there a suitable API method. Using injected dependencies \u00b6 Commander by default injects 4 dependencies into a plugin -- Core , API , Util , and Settings . However, it is worth noting that the Settings dependency is a copied table, changes to it will not be reflected in the actual settings module. To begin using either one of the dependencies, use the line package.Dependency , where Dependency is the name of the dependency, and package is the package table (Not to be confused with the package target table). Examples \u00b6 API Checker A checker is a function that validates the user to determine whether the user is an administrator, and which group do they belong to. Luckily, the API has exposed a method to assign a new checker, which is API.addChecker ( read more ). First, create a package and use the standard format above local package = { Name = \"Checker\" , Description = \"Plugin Description\" , Author = \"User\" , Class = \"Plugin\" , Target = {} } function package . Target : Init () end return package Administration groups and assignee data can be found in the configuration module, which can be required via package.Core.Settings , you should initialize settings within the :Init() function. function package . Target : Init () package . Target . Settings = require ( package . Core . Settings ) end Now, we have to write the checker function, in this sitution, let's assume that you want to give everyone the highest administration group in the checker. It is not needed to follow this format for the checker, but it is recommended to do so, to maintain consistency within the ecosystem. Administration groups configuration can be accessed via Settings.Groups , where assignee data can be found in Settings.Permissions . The format of a group and assignee configuration can be found in this page A checker is expected to return an integer, which should be the index of the group configuration, inside the groups configuration table. function package . Target . onInvoke () return # package . Target . Settings . Groups -- This will give everyone the highest group end Now, once you are done writing the checker, make it so the API will load the checker, with the method API.addChecker function package . Target : Init () package . Target . Settings = require ( package . Core . Settings ) package . API . addChecker ( package . Target . onInvoke ) end That's all.","title":"Plugins"},{"location":"manual/plugins/#plugins","text":"In V2, we have introduced a brand new package system with a new package type called Plugin , which is used to extend existing features or add new features to Commander. Those can be UI plugins, API plugins, or plugins used by commands. In this page, we will walk you through the process of creating a plugin for Commander.","title":"Plugins"},{"location":"manual/plugins/#preparations","text":"Before building, we need: A proper installation of Commander 2.x.x Roblox Studio Rojo & External Code Editor (Optional)","title":"Preparations"},{"location":"manual/plugins/#start","text":"To make a plugin recognizable by Commander, you need to ensure the source file has the proper format and declares itself as a Plugin package. So, copy and paste the standard package format, which can be found here or in the page about packages in general. local package = { Name = \"Plugin\" , Description = \"Plugin Description\" , Author = \"User\" , Class = \"Plugin\" , Target = {} } function package . Target : Init () end return package It is also recommended to add the above code as a code snippet for future use. For plugins, Commander will call :Init() once all loading for packages has been complete, this includes injecting the necessary dependencies. If your plugin have to require dependencies found in the Core folder, but not in the Preloaded folder, it is a better idea to initialize those dependencies within the :Init() function, and assign them into the package.Target table. A plugin is not necessary to expose methods, a plugin can be a piece of run-once code. Plugins are injected automatically into the commands only, if you are attempting to adjust the API inside a plugin, it is best to look at the API documentation to see is there a suitable API method.","title":"Start"},{"location":"manual/plugins/#using-injected-dependencies","text":"Commander by default injects 4 dependencies into a plugin -- Core , API , Util , and Settings . However, it is worth noting that the Settings dependency is a copied table, changes to it will not be reflected in the actual settings module. To begin using either one of the dependencies, use the line package.Dependency , where Dependency is the name of the dependency, and package is the package table (Not to be confused with the package target table).","title":"Using injected dependencies"},{"location":"manual/plugins/#examples","text":"API Checker A checker is a function that validates the user to determine whether the user is an administrator, and which group do they belong to. Luckily, the API has exposed a method to assign a new checker, which is API.addChecker ( read more ). First, create a package and use the standard format above local package = { Name = \"Checker\" , Description = \"Plugin Description\" , Author = \"User\" , Class = \"Plugin\" , Target = {} } function package . Target : Init () end return package Administration groups and assignee data can be found in the configuration module, which can be required via package.Core.Settings , you should initialize settings within the :Init() function. function package . Target : Init () package . Target . Settings = require ( package . Core . Settings ) end Now, we have to write the checker function, in this sitution, let's assume that you want to give everyone the highest administration group in the checker. It is not needed to follow this format for the checker, but it is recommended to do so, to maintain consistency within the ecosystem. Administration groups configuration can be accessed via Settings.Groups , where assignee data can be found in Settings.Permissions . The format of a group and assignee configuration can be found in this page A checker is expected to return an integer, which should be the index of the group configuration, inside the groups configuration table. function package . Target . onInvoke () return # package . Target . Settings . Groups -- This will give everyone the highest group end Now, once you are done writing the checker, make it so the API will load the checker, with the method API.addChecker function package . Target : Init () package . Target . Settings = require ( package . Core . Settings ) package . API . addChecker ( package . Target . onInvoke ) end That's all.","title":"Examples"},{"location":"v1/","text":"Home \u00b6 The Commander team has decided to merge with the current documentation content in v1 with the documentation software we use for v2, please note that the merge is not fully done and content may be missing. Visit the old documentation if you need to read content that is not covered in the new documentation yet. Content covered: - API Content not covered: - Packages - Themes - Settings - Group Admins","title":"Home"},{"location":"v1/#home","text":"The Commander team has decided to merge with the current documentation content in v1 with the documentation software we use for v2, please note that the merge is not fully done and content may be missing. Visit the old documentation if you need to read content that is not covered in the new documentation yet. Content covered: - API Content not covered: - Packages - Themes - Settings - Group Admins","title":"Home"},{"location":"v1/manual/api/","text":"API \u00b6 The API is a collection of reusable functions that helps to reduce the size of a package, or for developers to communicate with Commander externally. As the API is exposed to the server context, please be aware of backdoors, as they may have codes to intervene Commander. Reasons to use \u00b6 There are many reasons to use the API over a custom implementation when available, not just to maintain consistency across every packages in your Commander installation, but also for your own goods when making packages for Commander. Here's a few of the reasons to use the API: Consistency By using the API for your packages, this creates a higher consistency between each other, ensuring the quality remains the same. Less duplicates Write less line for the same functionality -- The API is a collection of reusable functions, in which your packages can make use of the API to do a Commander-specific task (fetching administrator info, etc), without writing the implementation again and again for each package. Safer The API is constantly maintained by the Commander team, your packages always stay up-to-date and safe-to-use when we update the API. A custom implementation has to be maintained by the one who coded it, and when there is an update for Commander which affects the implementation, then the package is likely to be affected. Methods \u00b6 Players \u00b6 sendModal \u00b6 BindableEvent API.Players.sendModal( player Player, string? Title) Sends a modal request to the defined user, asking for a string input. Returns a BindableEvent which fires upon interaction by the user. sendList \u00b6 void API.Players.sendList( player Player, string Title, Array List) Sends a window request with a list, displaying the content found in the array. executeWithPrefix \u00b6 boolean API.Players.executeWithPrefix( player Player, string Target, function Callback) Calls the defined callback for the defined Target, can be a player name/Id, or a prefix (all, others) Returns a boolean which indicates whether is the target present or not. getPlayerByName \u00b6 Player? API.Players.getPlayerByName( string Player) Gets the player by its name, this only works when the player is ingame. Returns the player object if present, otherwise nil. getPlayerByNamePartial \u00b6 Player? API.Players.getPlayerByNamePartial( string Player, string? Title) Gets the player by a part of its name, this only works when the player is ingame. Returns the player object if present, otherwise nil. getCharacter \u00b6 Model? API.Players.getCharacter( player Player) A safer implementation to retrieve the player character, only returns it if the character is loaded. getUserIdFromName \u00b6 number|string API.Players.getUserIdFromName( string Name) Returns the UserId from its name if the User is present. Returns a string if the operation failed. filterString \u00b6 boolean, string API.Players.filterString( player From, string? Content) Sends a content filter request to Roblox, returns the status of the request, along with the result or the error messsage if the operation failed. message \u00b6 void API.Players.message( Player|string To, string From, string Content, number? Duration) Sends a centered message to the corresponding player(s), filter the content manually if needed. hint \u00b6 void API.Players.hint( Player|string To, string From, string Content, number? Duration) Sends a less-disturbing notification to the corresponding player(s), filter the content manually if needed. notify \u00b6 void API.Players.notify( Player|string To, string From, string Content) Sends a notification that is not time limited, at the bottom right corner. If you are looking for an option for user to interact with the notification, use notifyWithAction notifyWithAction \u00b6 BindableEvent API.Players.notify( Player|string To, string Type, string From, string Content) Like notify , but this returns a BindableEvent , which fires upon interaction ends. setTransparency \u00b6 void API.Players.setTransparency( Model Character, number Alpha) Sets the transparency of a character. checkPermission \u00b6 boolean API.Players.checkPermission( number Player, string CommandName) Checks if the user is allowed to run the specific command, returns a boolean that indicates the status. getAdminStatus \u00b6 boolean API.Players.getAdminStatus( number Player) Checks if user is allowed to use Commander. getAdminLevel \u00b6 string? API.Players.getAdminLevel( number Player) Gets user's level of authorization, returns void if the user is not authorized. getAdmins \u00b6 void API.Players.getAdmins() Fetches a list of administrators defined in the Settings module getAvailableAdmins \u00b6 number API.Players.getAvailableAdmins() Returns a number of administrators available in that server listenToPlayerAdded \u00b6 void API.Players.listenToPlayerAdded( function Callback) Registers a callback to PlayerAdded event Global API \u00b6 If you plan to integrate your game's system with Commander, you can consider to use our global API, stored in the _G environment with name CommanderAPI . The global API is not available for clients context however, only communicate with Commander in server context as it's safer. Here is the list of all available methods in the global API, the reference of the methods are exactly the same as the one in the builtin API unless specified. checkHasPermission checkAdmin getAdminLevel getAvailableAdmins getAdminStatus getAdmins","title":"API"},{"location":"v1/manual/api/#api","text":"The API is a collection of reusable functions that helps to reduce the size of a package, or for developers to communicate with Commander externally. As the API is exposed to the server context, please be aware of backdoors, as they may have codes to intervene Commander.","title":"API"},{"location":"v1/manual/api/#reasons-to-use","text":"There are many reasons to use the API over a custom implementation when available, not just to maintain consistency across every packages in your Commander installation, but also for your own goods when making packages for Commander. Here's a few of the reasons to use the API: Consistency By using the API for your packages, this creates a higher consistency between each other, ensuring the quality remains the same. Less duplicates Write less line for the same functionality -- The API is a collection of reusable functions, in which your packages can make use of the API to do a Commander-specific task (fetching administrator info, etc), without writing the implementation again and again for each package. Safer The API is constantly maintained by the Commander team, your packages always stay up-to-date and safe-to-use when we update the API. A custom implementation has to be maintained by the one who coded it, and when there is an update for Commander which affects the implementation, then the package is likely to be affected.","title":"Reasons to use"},{"location":"v1/manual/api/#methods","text":"","title":"Methods"},{"location":"v1/manual/api/#players","text":"","title":"Players"},{"location":"v1/manual/api/#sendmodal","text":"BindableEvent API.Players.sendModal( player Player, string? Title) Sends a modal request to the defined user, asking for a string input. Returns a BindableEvent which fires upon interaction by the user.","title":"sendModal"},{"location":"v1/manual/api/#sendlist","text":"void API.Players.sendList( player Player, string Title, Array List) Sends a window request with a list, displaying the content found in the array.","title":"sendList"},{"location":"v1/manual/api/#executewithprefix","text":"boolean API.Players.executeWithPrefix( player Player, string Target, function Callback) Calls the defined callback for the defined Target, can be a player name/Id, or a prefix (all, others) Returns a boolean which indicates whether is the target present or not.","title":"executeWithPrefix"},{"location":"v1/manual/api/#getplayerbyname","text":"Player? API.Players.getPlayerByName( string Player) Gets the player by its name, this only works when the player is ingame. Returns the player object if present, otherwise nil.","title":"getPlayerByName"},{"location":"v1/manual/api/#getplayerbynamepartial","text":"Player? API.Players.getPlayerByNamePartial( string Player, string? Title) Gets the player by a part of its name, this only works when the player is ingame. Returns the player object if present, otherwise nil.","title":"getPlayerByNamePartial"},{"location":"v1/manual/api/#getcharacter","text":"Model? API.Players.getCharacter( player Player) A safer implementation to retrieve the player character, only returns it if the character is loaded.","title":"getCharacter"},{"location":"v1/manual/api/#getuseridfromname","text":"number|string API.Players.getUserIdFromName( string Name) Returns the UserId from its name if the User is present. Returns a string if the operation failed.","title":"getUserIdFromName"},{"location":"v1/manual/api/#filterstring","text":"boolean, string API.Players.filterString( player From, string? Content) Sends a content filter request to Roblox, returns the status of the request, along with the result or the error messsage if the operation failed.","title":"filterString"},{"location":"v1/manual/api/#message","text":"void API.Players.message( Player|string To, string From, string Content, number? Duration) Sends a centered message to the corresponding player(s), filter the content manually if needed.","title":"message"},{"location":"v1/manual/api/#hint","text":"void API.Players.hint( Player|string To, string From, string Content, number? Duration) Sends a less-disturbing notification to the corresponding player(s), filter the content manually if needed.","title":"hint"},{"location":"v1/manual/api/#notify","text":"void API.Players.notify( Player|string To, string From, string Content) Sends a notification that is not time limited, at the bottom right corner. If you are looking for an option for user to interact with the notification, use notifyWithAction","title":"notify"},{"location":"v1/manual/api/#notifywithaction","text":"BindableEvent API.Players.notify( Player|string To, string Type, string From, string Content) Like notify , but this returns a BindableEvent , which fires upon interaction ends.","title":"notifyWithAction"},{"location":"v1/manual/api/#settransparency","text":"void API.Players.setTransparency( Model Character, number Alpha) Sets the transparency of a character.","title":"setTransparency"},{"location":"v1/manual/api/#checkpermission","text":"boolean API.Players.checkPermission( number Player, string CommandName) Checks if the user is allowed to run the specific command, returns a boolean that indicates the status.","title":"checkPermission"},{"location":"v1/manual/api/#getadminstatus","text":"boolean API.Players.getAdminStatus( number Player) Checks if user is allowed to use Commander.","title":"getAdminStatus"},{"location":"v1/manual/api/#getadminlevel","text":"string? API.Players.getAdminLevel( number Player) Gets user's level of authorization, returns void if the user is not authorized.","title":"getAdminLevel"},{"location":"v1/manual/api/#getadmins","text":"void API.Players.getAdmins() Fetches a list of administrators defined in the Settings module","title":"getAdmins"},{"location":"v1/manual/api/#getavailableadmins","text":"number API.Players.getAvailableAdmins() Returns a number of administrators available in that server","title":"getAvailableAdmins"},{"location":"v1/manual/api/#listentoplayeradded","text":"void API.Players.listenToPlayerAdded( function Callback) Registers a callback to PlayerAdded event","title":"listenToPlayerAdded"},{"location":"v1/manual/api/#global-api","text":"If you plan to integrate your game's system with Commander, you can consider to use our global API, stored in the _G environment with name CommanderAPI . The global API is not available for clients context however, only communicate with Commander in server context as it's safer. Here is the list of all available methods in the global API, the reference of the methods are exactly the same as the one in the builtin API unless specified. checkHasPermission checkAdmin getAdminLevel getAvailableAdmins getAdminStatus getAdmins","title":"Global API"}]}